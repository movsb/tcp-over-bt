package main

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"log"
	"os"
	"runtime"
	"sync"

	"tinygo.org/x/bluetooth"
)

func caller() (string, int) {
	_, file, line, _ := runtime.Caller(2)
	return file, line
}

func Must(err error) {
	if err != nil {
		file, line := caller()
		log.Fatalf(`%s:%d: %v`, file, line, err)
	}
}

func Must1[T any](t T, err error) T {
	if err != nil {
		file, line := caller()
		log.Fatalf(`%s:%d: %v`, file, line, err)
	}
	return t
}

// Randomly generated by `uuidgen`.
var (
	uuidService = Must1(bluetooth.ParseUUID(`923BFB18-A711-4923-82A8-988AD38AF7C1`))
	uuidTx      = Must1(bluetooth.ParseUUID(`3F33F755-C5A9-4F25-B0CA-8BFFEF13B905`))
	uuidRx      = Must1(bluetooth.ParseUUID(`41F94EAB-B906-4AE6-BEB9-0D5CA55EC4CB`))
	uuidCtrl    = Must1(bluetooth.ParseUUID(`A004120C-300F-4049-8280-E98AC615ACA1`))
)

// Anybody knows the max packet size of bluetooth?
// Without a limit, there will be an error.
//
// GetMTU()?
const maxPacketSize = 64

type SegmentedWriter struct {
	n int
	w io.Writer
}

func NewSegmentedWriter(w io.Writer, n int) io.Writer {
	return &SegmentedWriter{w: w, n: n}
}

func (w *SegmentedWriter) Write(p []byte) (int, error) {
	count := 0
	for len(p) > 0 {
		n, err := w.w.Write(p[:min(w.n, len(p))])
		count += n
		if err != nil {
			return count, err
		}
		p = p[n:]
	}
	return count, nil
}

// Notification callback is called in a separate goroutine, so it may be in wrong order.
// https://github.com/tinygo-org/bluetooth/blob/b82048cd9da0fdabb6f2508f461c364184087b3a/gap_darwin.go#L223
//
// Packets may be in wrong order, but they're not gonna be lost, since we're Write(WithResponse).
// This is to fix the receive order.
//
// And, there's no need to implement an ARQ protocol. No packet lost, only unordered.
type SequencedPacket struct {
	ctx context.Context

	sendSeq uint8
	writer  io.Writer

	recvSeq     uint8
	recvBacklog map[uint8][]byte
	recvBuf     *bytes.Buffer
	recvReady   chan struct{}
	lock        sync.Mutex
}

// When ctx Done, blocking Read is cancelled.
func NewSequencedPacket(ctx context.Context, w io.Writer) *SequencedPacket {
	return &SequencedPacket{
		ctx: ctx,

		sendSeq: 0,
		writer:  w,

		recvSeq:     0,
		recvBacklog: map[uint8][]byte{},
		recvBuf:     bytes.NewBuffer(nil),
		recvReady:   make(chan struct{}),
	}
}

func (sp *SequencedPacket) Receive(p []byte) error {
	if len(p) < 2 {
		return fmt.Errorf(`invalid packet received`)
	}

	sp.lock.Lock()
	defer sp.lock.Unlock()

	seq, data := p[0], p[1:]

	if seq < sp.recvSeq {
		return fmt.Errorf(`invalid packet received: seq too small`)
	} else if seq > sp.recvSeq {
		// protocol mismatch if this is the very first packet received.
		// since seq will loop back, this condition is not enough.
		if sp.recvSeq == 0 {
		}

		sp.recvBacklog[seq] = data
		// log.Println(`unordered packet received`, sp.recvSeq, seq)
		return nil
	}

	sp.recvSeq++
	sp.recvBuf.Write(data)

	for {
		saved, ok := sp.recvBacklog[sp.recvSeq]
		if !ok {
			break
		}
		sp.recvBuf.Write(saved)
		delete(sp.recvBacklog, sp.recvSeq)
		sp.recvSeq++
	}

	select {
	case sp.recvReady <- struct{}{}:
	default:
	}

	return nil
}

func (sp *SequencedPacket) Write(p []byte) (int, error) {
	wrapped := append([]byte{sp.sendSeq}, p...)
	sp.sendSeq++
	n, err := sp.writer.Write(wrapped)
	if err != nil {
		return 0, err
	}
	return n - 1, nil
}

func (sp *SequencedPacket) Read(p []byte) (int, error) {
	sp.lock.Lock()
	if sp.recvBuf.Len() <= 0 {
		sp.lock.Unlock()
		select {
		case <-sp.recvReady:
			sp.lock.Lock()
		case <-sp.ctx.Done():
			return 0, sp.ctx.Err()
		}
	}
	n, err := sp.recvBuf.Read(p)
	sp.lock.Unlock()
	return n, err
}

var (
	errConnClosed = fmt.Errorf(`tcp-over-bt: connection closed`)
)

func Stream(a, b io.ReadWriter) {
	exit := make(chan struct{}, 2)

	go func() {
		io.Copy(a, b)
		exit <- struct{}{}
	}()

	go func() {
		io.Copy(b, a)
		exit <- struct{}{}
	}()

	<-exit
}

type Conn interface {
	io.Reader
	io.Writer
}

type ReadWriter struct {
	io.Reader
	io.Writer
}

var Stdio Conn = ReadWriter{
	os.Stdin,
	os.Stdout,
}
